# -*- coding: utf-8 -*-
"""[NegotiationArena] Run BuySell Game

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ff2dZjt7O-opRz1BTeONLEQ2ITnTaT7H

# How Well Can LLMs Negotiate? NegotiationArena. Platform and Analysis

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1Z1M97k4GEf2_v48cdA96BANTAp0yK2IM?usp=sharing)
[![Arxiv Preprint](https://img.shields.io/badge/arXiv-2402.05863-0.svg)](https://arxiv.org/abs/2402.05863)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![GitHub](https://img.shields.io/badge/Code-GitHub-blue?logo=github)](https://github.com/vinid/NegotiationArena)


NegotiationArena is a platform to develop games to better understand how agents interact with each other to solve engotiation problems. In the image below you see an example of negotiation between the agents.

<div align="center">
<img src="https://github.com/vinid/NegotiationArena/blob/main/figures/negotiation_intro.jpg?raw=true" width=400>
</div>

## Who is this tutorial for

**If you want to run one of the games. The game we are going to run is the BuySell game.**


From the paper:


> We introduce a seller and buyer game involving two agents, one looking to sell a set of resources and one looking to buy them, similar to other approaches in the literature. We imbue agents with some beliefs about the object being sold, but unlike the ultimatum game, the seller and buyer game is an incomplete information game, i.e., players do not have complete information about other players (e.g., their beliefs). Only the seller is aware of the production cost of the object, and only the buyer is assigned and is aware of their willingness to pay for the object. Given these beliefs, the seller and the buyer are prompted to sell and buy the object, respectively. The seller starts first: reproducing a scenario in which the object is already on sale.

Here we run the BuySell game.

### **Let's Start!**

We now install and load what we need to run the games.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# !git clone https://github.com/vinid/NegotiationArena/
# !pip install -r NegotiationArena/requirements.txt

import sys
from dotenv import load_dotenv

from langchain.agents import tool
from langgraph.checkpoint.memory import MemorySaver
from langgraph.prebuilt import create_react_agent
from negotiationarena.llm.custom_chat_model import CustomChatModel

from negotiationarena.agents.chatgpt import ChatGPTAgent
from negotiationarena.agents.local_agent import LocalAgent
from negotiationarena.game_objects.resource import Resources
from negotiationarena.game_objects.goal import UltimatumGoal
from negotiationarena.game_objects.valuation import Valuation
from negotiationarena.constants import AGENT_ONE, AGENT_TWO, MONEY_TOKEN
import traceback
from games.ultimatum.game import MultiTurnUltimatumGame

"""## **Important Background**


We first need to introduce a game prompt. This prompt will describe the rules of the game.

By default, we support a TAG/XML-like language for communcation. Thus we will ask all the agents to follow this formatting.

```
<answer> REJECT </answer>
<message> I don't like your trade, here's my counter offer. </message>
<trade> Player RED Gives X:50 | Player Blue Gives Y:40 </trade>
```

## **Prompt**

Under this cell you have the entire prompt of the game. The prompt you see is the prompt of the seller. The buyer's one is slightly different (the buyer has a different goal)

```You are playing game where you are buying or selling an object. There is only one object for sale/purcahse.

Player RED is going to sell one object. Player BLUE gives ZUP to buy resources.

RULES:

1. You must always respond with:

    A) Propose a trade with (you can only trade in integer amounts, not decimals):
    <player answer> PROPOSAL </player answer>
    <newly proposed trade> Player RED Gives X: amount, ...| Player BLUE Gives ZUP: amount </newly proposed trade>

    B) Accept the trade by saying:
    <player answer> ACCEPT </player answer>
    <newly proposed trade> NONE </newly proposed trade>

    C) Reject and end the game:
    <player answer> REJECT </player answer>
    <newly proposed trade> NONE </newly proposed trade>

    Note: The game will end if one of the players ACCEPT OR REJECT. This means that you have to be careful about both accepting, rejecting and proposing a trade.

2. You are allowed at most 4 proposals of your own to complete the game, after which you can only reply with ACCEPT or REJECT.
DO NOT propose a new trade after 4 proposals. Your limit for proposals is 4.

3. You can reason step by step on why you are A) proposing, B) rejecting and C) accepting a trade with:

<reason> [add reasoning] </reason> add as much text as you want

This information will not be sent to the other player. It is just for you to keep track of your reasoning.

4. At each turn send messages to each other by using the following format:

<message>your message here</message>

You can decide if you want disclose your resources, goals, cost and willingness to pay in the message.


Here is what you have access to:

Object that is being bought/sold: X
<my resources> X: 1 </my resources>
<my goals> Sell resources for <ZUP>. It costed X: 40 ZUP to produce the resources </my goals>,


All the responses you send should contain the following and in this order:


<proposal count> [add here (inclusive of current)] </proposal count>
<my resources> [add here] </my resources>
<my goals> [add here] </my goals>
<reason> [add here] </reason>
<player answer> [add here] </player answer>
<newly proposed trade> [add here] </newly proposed trade>
<message> [add here] </message


Please be sure to include all.
```

## **Setup**

**You need to upload an environment file called "env" that should have the following content:**

```
OPENAI_API_KEY=
```

Your colab session is local to your account, but if you don't like putting your OpenAI key in colab i'd just create a throwaway one just for the sake of playing with the example.


**Be mindful** of what you do! These games should end very quickly and does should not cost much, but you might end up paying more if you make the agents chat for 1000 turns!
"""

# the project assumes you have your environment variable in an env file.
load_dotenv("env")

@tool
def get_best_split(num_resources: int) -> str:
    """
    Returns the best resource split to propose according to Game Theory.
    
    Args:
        num_resources (int): the number of resources (dollars) you currently have
    Returns:
        str: the proposed best split
    """
    if num_resources > 0:
        return f"Keep {num_resources - 1} dollars and offer the opponent 1 dollar. Make it clear that this is the best offer"
    else:
        return "Accept any positive split"

for _ in range(3):
    try:

        # we implement two chatgpt4 agents.
        a1 = LocalAgent(agent_name=AGENT_ONE, model_type="llama3-8b", temperature=0.3, tools=[get_best_split])
        # a1 = ChatGPTAgent(agent_name=AGENT_ONE, model="gpt-4o")
        a2 = ChatGPTAgent(agent_name=AGENT_TWO, model="gpt-4o")

        # buy sell game
        c = MultiTurnUltimatumGame(
            players=[a1, a2],
            iterations=4,
            resources_support_set=Resources({"Dollars": 0}),
            player_goals=[
                UltimatumGoal(),
                UltimatumGoal(),
            ],
            player_initial_resources=[
                Resources({"Dollars": 100}),
                Resources({"Dollars": 0}),
            ],
            player_social_behaviour=[
                "",
                ""
            ],
            player_roles=[
                f"You are {AGENT_ONE}.",
                f"You are {AGENT_TWO}.",
            ],
            log_dir=".logs/ultimatum_multi_v0",
        )

        c.run()
        print("Run Success!")
        break
    except Exception as e:
        exception_type = type(e).__name__
        exception_message = str(e)
        stack_trace = traceback.format_exc()

        # Print or use the information as needed
        print(f"Exception Type: {exception_type}")
        print(f"Exception Message: {exception_message}")
        print(f"Stack Trace:\n{stack_trace}")
        
        
